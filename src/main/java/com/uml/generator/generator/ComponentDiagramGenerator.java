package com.uml.generator.generator;

import com.uml.generator.analyzer.TraceAggregator;
import com.uml.generator.model.Trace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Generates UML Component Diagrams from aggregated Jaeger traces.
 * Shows services as components with their interfaces and dependencies.
 */
public class ComponentDiagramGenerator implements DiagramGenerator {

    private static final Logger logger = LoggerFactory.getLogger(ComponentDiagramGenerator.class);

    @Override
    public String getDiagramType() {
        return "component";
    }

    @Override
    public String generatePlantUML(List<Trace> traces) {
        if (traces == null || traces.isEmpty()) {
            logger.warn("No traces provided for component diagram generation");
            return "";
        }

        TraceAggregator aggregator = new TraceAggregator(traces);

        StringBuilder puml = new StringBuilder();

        // Add modern theme and styling
        puml.append("@startuml\n");
        puml.append("!theme cerulean-outline\n\n");

        // Skinparam for additional customization
        puml.append("skinparam componentStyle rectangle\n");
        puml.append("skinparam shadowing false\n");
        puml.append("skinparam roundcorner 5\n");
        puml.append("skinparam defaultTextAlignment center\n\n");

        // Color scheme for stereotypes
        puml.append("skinparam component {\n");
        puml.append("  BackgroundColor<<Web UI>> LightBlue\n");
        puml.append("  BackgroundColor<<Microservice>> LightGreen\n");
        puml.append("  BackgroundColor<<gRPC Service>> PaleGreen\n");
        puml.append("  BackgroundColor<<Database>> LightYellow\n");
        puml.append("  BackgroundColor<<Cache>> Wheat\n");
        puml.append("  BorderColor Black\n");
        puml.append("  FontSize 12\n");
        puml.append("}\n\n");

        // Dynamic title based on trace source
        String diagramTitle = "Component Diagram - System Architecture";
        if (!traces.isEmpty() && traces.get(0).getSourceName() != null) {
            String sourceName = traces.get(0).getSourceName();
            // Clean and capitalize
            sourceName = sourceName.replace("_", " ").replace("-", " ");
            sourceName = sourceName.substring(0, 1).toUpperCase() + sourceName.substring(1);
            diagramTitle = "Component Diagram - " + sourceName;
        }
        puml.append("title ").append(diagramTitle).append("\n\n");

        // Single-line header (PlantUML has issues with multi-line headers in component
        // diagrams)
        puml.append("caption Generated by UML Generator - Jaeger Trace Analysis\n\n");

        // Get all services, metadata and their relationships
        Set<String> services = aggregator.getAllServices();
        Map<String, Map<String, Object>> serviceMetadata = aggregator.getServiceMetadata();
        Map<String, Map<String, Set<String>>> serviceCalls = aggregator.getServiceCalls();

        // Define all components with stereotypes
        puml.append("' Service Components\n");
        for (String service : services) {
            Map<String, Object> metadata = serviceMetadata.get(service);
            String stereotype = detectServiceStereotype(service, metadata);

            puml.append("component \"").append(service).append("\"");
            if (stereotype != null && !stereotype.isEmpty()) {
                puml.append(" <<").append(stereotype).append(">>");
            }
            puml.append("\n");
        }
        puml.append("\n");

        // Define dependencies using interfaces with operations
        puml.append("' Service interfaces and dependencies\n");

        int interfaceCounter = 0;
        int totalDependencies = 0;

        for (Map.Entry<String, Map<String, Set<String>>> callerEntry : serviceCalls.entrySet()) {
            String callerService = callerEntry.getKey();
            Map<String, Set<String>> calleeMap = callerEntry.getValue();

            for (Map.Entry<String, Set<String>> calleeEntry : calleeMap.entrySet()) {
                String calleeService = calleeEntry.getKey();
                Set<String> operations = calleeEntry.getValue();

                // Create interface for the callee service (without operations block)
                String interfaceName = "I" + interfaceCounter++;
                totalDependencies++;

                puml.append("interface \"").append(calleeService).append(" API\" as ").append(interfaceName);
                puml.append("\n");

                // Caller uses the interface
                puml.append("\"").append(callerService).append("\" ..> ").append(interfaceName).append(" : uses\n");

                // Interface is provided by callee
                puml.append(interfaceName).append(" -- \"").append(calleeService).append("\"\n");

                // Add operations as a note attached to the interface
                if (operations != null && !operations.isEmpty()) {
                    String operationsList = formatOperationsForNote(operations, 5);
                    puml.append("note right of ").append(interfaceName).append("\n");
                    puml.append("  **Operations:**\n");
                    puml.append(operationsList);
                    puml.append("end note\n");
                }

                puml.append("\n");
            }
        }

        // Add legend
        puml.append("legend right\n");
        puml.append("  |= Symbol |= Meaning |\n");
        puml.append("  | <<Web UI>> | Frontend/Web Interface |\n");
        puml.append("  | <<Microservice>> | Backend Microservice |\n");
        puml.append("  | <<gRPC Service>> | gRPC-based Service |\n");
        puml.append("  | ..> | Uses/Depends On |\n");
        puml.append("  | -- | Provides Interface |\n");
        puml.append("endlegend\n\n");

        // Footer with timestamp and statistics
        puml.append("footer\n");
        puml.append("Generated: ").append(java.time.LocalDateTime.now().format(
                java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        puml.append(" | Services: ").append(services.size());
        puml.append(" | Dependencies: ").append(totalDependencies).append("\n");
        puml.append("endfooter\n\n");

        puml.append("@enduml");

        logger.info("Generated component diagram with {} service(s) and {} dependencies",
                services.size(), totalDependencies);

        return puml.toString();
    }

    /**
     * Detects the stereotype for a service based on its name and metadata.
     * 
     * @param serviceName The name of the service
     * @param metadata    The metadata tags from the trace
     * @return The stereotype string, or null if no specific type detected
     */
    private String detectServiceStereotype(String serviceName, Map<String, Object> metadata) {
        if (serviceName == null) {
            return null;
        }

        String lowerName = serviceName.toLowerCase();

        // Check for frontend/UI services
        if (lowerName.contains("frontend") || lowerName.contains("ui") ||
                lowerName.contains("web") || lowerName.contains("client")) {
            return "Web UI";
        }

        // Check for database services
        if (lowerName.contains("database") || lowerName.contains("db") ||
                lowerName.contains("mongo") || lowerName.contains("postgres") ||
                lowerName.contains("mysql") || lowerName.contains("redis")) {
            return "Database";
        }

        // Check for cache services
        if (lowerName.contains("cache") || lowerName.contains("redis") ||
                lowerName.contains("memcache")) {
            return "Cache";
        }

        // Check metadata for gRPC
        if (metadata != null) {
            Object rpcSystem = metadata.get("rpc.system");
            if (rpcSystem != null && rpcSystem.toString().toLowerCase().contains("grpc")) {
                return "gRPC Service";
            }
        }

        // Generic microservice for services ending in 'service'
        if (lowerName.endsWith("service")) {
            return "Microservice";
        }

        return null;
    }

    /**
     * Formats a list of operations for display in an interface, limiting to
     * maxOperations.
     * 
     * @param operations    The set of operation names
     * @param maxOperations Maximum number of operations to display
     * @return Formatted string with operations
     */
    private String formatOperationsList(Set<String> operations, int maxOperations) {
        if (operations == null || operations.isEmpty()) {
            return "  + execute()\n";
        }

        StringBuilder formatted = new StringBuilder();
        int count = 0;

        for (String operation : operations) {
            if (count >= maxOperations) {
                break;
            }

            // Clean operation name
            String cleanOp = com.uml.generator.util.NameUtils.cleanOperationName(operation);
            formatted.append("  + ").append(cleanOp).append("()\n");
            count++;
        }

        // Add overflow indicator if there are more operations
        if (operations.size() > maxOperations) {
            int remaining = operations.size() - maxOperations;
            formatted.append("  + ... (+").append(remaining).append(" more)\n");
        }

        return formatted.toString();
    }

    /**
     * Formats a list of operations for display in a note.
     * 
     * @param operations    The set of operation names
     * @param maxOperations Maximum number of operations to display
     * @return Formatted string for note content
     */
    private String formatOperationsForNote(Set<String> operations, int maxOperations) {
        if (operations == null || operations.isEmpty()) {
            return "  • execute()\n";
        }

        StringBuilder formatted = new StringBuilder();
        int count = 0;

        for (String operation : operations) {
            if (count >= maxOperations) {
                break;
            }

            // Clean operation name
            String cleanOp = com.uml.generator.util.NameUtils.cleanOperationName(operation);
            formatted.append("  • ").append(cleanOp).append("\n");
            count++;
        }

        // Add overflow indicator if there are more operations
        if (operations.size() > maxOperations) {
            int remaining = operations.size() - maxOperations;
            formatted.append("  • ... (+").append(remaining).append(" more)\n");
        }

        return formatted.toString();
    }
}
